---
title: "paper"
author: "Ali Youssef"
format: docx
editor: visual
---

## 

# UPS1 Case Study 0

The dataset consists of DIA proteomics data from a UPS1-spiked E. coli protein mixture. Eight different concentrations of UPS1 were used (0.1 to 50 fmol), grouped into two categories: low concentrations (0.1–2.5 fmol, labeled as Conc. 2) and high concentrations (5–50 fmol, labeled as Conc. 1). In this dataset 48 HUMAN UPS1 proteins were detected. The data is provided in a `SummarizedExperiment` format. This example illustrates the application of LimROTS in a simple case where two groups are compared, considering only the concentrations and no other parameters. 48 UPS1-spiked human proteins were detected in this dataset.

## Run LimROTS

```{r results = "hide" , message = FALSE, warning = FALSE, eval = TRUE}
# Load necessary packages
library(LimROTS)
library(parallel)
# Load the dataset
data("UPS1.Case0")
print(UPS1.Case0)
# Set random seed for reproducibility
set.seed(1234, kind = "default")
# Set metadata and formula for LimROTS analysis
meta.info <- "Conc."
B <- 1000  # Number of bootstrap samples
K <- dim(UPS1.Case0)[1]/4  # Set the value for K based on the data size
K <- floor(K) 
num_cores <- 30  # Number of cores for parallel processing
cluster <- makeCluster(num_cores)  # Create a parallel cluster
group.name <- "Conc."
formula.str <- "~ 0 + Conc."  # Formula for group comparison
# Run LimROTS analysis with trend and robust settings enabled
limrots.result <- LimROTS(data.exp = UPS1.Case0, 
                          B = B, K = K, meta.info = meta.info, 
                          cluster = cluster, group.name = group.name, 
                          formula.str = formula.str, trend = TRUE, robust = TRUE)
saveRDS(limrots.result, "../LimROTS paper/UPS1.Case0.LimROTS.rds")
```

## Run ROTS

```{r results = "hide" , message = FALSE, warning = FALSE, eval=FALSE}
# Load necessary packages
library(LimROTS)
library(parallel)
# Load the dataset
data("UPS1.Case0")
print(UPS1.Case0)
# Set random seed for reproducibility
set.seed(1234, kind = "default")
# Set metadata and formula for LimROTS analysis
meta.info <- "Conc."
B <- 1000  # Number of bootstrap samples
K <- dim(UPS1.Case0)[1]/4  # Set the value for K based on the data size
K <- floor(K) 
num_cores <- 30  # Number of cores for parallel processing
cluster <- makeCluster(num_cores)  # Create a parallel cluster
group.name <- "Conc."
formula.str <- "Conc."
# Run LimROTS analysis with trend and robust settings enabled
rots.result <- LimROTS(data.exp = UPS1.Case0, 
                          B = B, K = K, meta.info = meta.info, 
                          cluster = cluster, group.name = group.name, 
                          formula.str = formula.str, trend = TRUE, robust = TRUE, n.ROTS = TRUE)
saveRDS(rots.result, "../LimROTS paper/UPS1.Case0.ROTS.rds")
```

## Run limma

```{r results = "hide" , message = FALSE, warning = FALSE, eval=FALSE}
library(limma)
library(SummarizedExperiment, quietly = T, warn.conflicts = T)
data("UPS1.Case0")
data <- assay(UPS1.Case0)
formula.str <- "~ 0 + Conc."
meta.info <- data.frame(colData(UPS1.Case0), check.names = FALSE, row.names = row.names(colData(UPS1.Case0)))
meta.info$sample.id <- NULL
design.matrix <- model.matrix(formula(formula.str), data = meta.info)
colnames(design.matrix) <- make.names(colnames(design.matrix))
fit <- lmFit(data, design.matrix)
cont_matrix <- makeContrasts("Conc.1-Conc.2",  levels=design.matrix)
fit2 <- contrasts.fit(fit, cont_matrix)
fit.ebayes <- eBayes(fit2, trend=TRUE, robust=TRUE)
limma.result <- topTable(fit.ebayes, coef="Conc.1-Conc.2" , number = "Inf")
saveRDS(limma.result, "../LimROTS paper/UPS1.Case0.limma.rds")
```

## Run t-test

```{r eval=FALSE}
library(SummarizedExperiment, quietly = T, warn.conflicts = F)
data("UPS1.Case0")
data <- assay(UPS1.Case0)
meta.info <- data.frame(colData(UPS1.Case0), check.names = FALSE, row.names = row.names(colData(UPS1.Case0)))
t.test.result <- data.frame()

for(i in 1:nrow(data)){
  p <- t.test(data[i,1:12], data[i,13:24])
  t.test.result <- rbind(t.test.result, data.frame(protein = row.names(data)[i] ,p.value = p$p.value))
}

t.test.result$fdr <- p.adjust(t.test.result$p.value)
saveRDS(t.test.result, "../LimROTS paper/UPS1.Case0.t.test.rds")
```

## Comparison

```{r results = "hide" , message = FALSE, warning = FALSE}
library(caret, quietly = T, warn.conflicts = T)

limrots.result <- readRDS("../LimROTS paper/UPS1.Case0.LimROTS.rds")
rots.result <- readRDS("../LimROTS paper/UPS1.Case0.ROTS.rds")
limma.result <- readRDS("../LimROTS paper/UPS1.Case0.limma.rds")
t.test.result <- readRDS("../LimROTS paper/UPS1.Case0.t.test.rds")


TP <- UPS1.Case0@elementMetadata@listData[["GeneID"]]
TP <- TP[grepl("HUMAN" , TP)]

predictions_limrots <- limrots.result$FDR < 0.01
predictions_limrots <- factor(predictions_limrots, levels = c(TRUE, FALSE))
true_labels_limrots <- ifelse(row.names(limrots.result$data) %in% TP , TRUE, FALSE)
true_labels_limrots <- factor(true_labels_limrots, levels = c(TRUE, FALSE))
conf_matrix_limrots <- confusionMatrix(predictions_limrots, true_labels_limrots)

predictions_rots <- rots.result$FDR < 0.01
predictions_rots <- factor(predictions_rots, levels = c(TRUE, FALSE))
true_labels_rots <- ifelse(row.names(rots.result$data) %in% TP , TRUE, FALSE)
true_labels_rots <- factor(true_labels_rots, levels = c(TRUE, FALSE))
conf_matrix_rots <- confusionMatrix(predictions_rots, true_labels_rots)

predictions_limma <- limma.result$adj.P.Val < 0.01
predictions_limma <- factor(predictions_limma, levels = c(TRUE, FALSE))
true_labels_limma <- ifelse(row.names(limma.result) %in% TP , TRUE, FALSE)
true_labels_limma <- factor(true_labels_limma, levels = c(TRUE, FALSE))
conf_matrix_limma <- confusionMatrix(predictions_limma, true_labels_limma)

predictions_t.test <- t.test.result$fdr < 0.01
predictions_t.test <- factor(predictions_t.test, levels = c(TRUE, FALSE))
true_labels_t.test <- ifelse(t.test.result$protein %in% TP , TRUE, FALSE)
true_labels_t.test <- factor(true_labels_t.test, levels = c(TRUE, FALSE))
conf_matrix_t.test <- confusionMatrix(predictions_t.test, true_labels_t.test)

```

```{r}
library(dplyr, quietly = T, warn.conflicts = T)  
library(ggplot2)
library(ggsci)

extract_metrics <- function(conf_matrix, method_name) {
  metrics <- c(
    conf_matrix$byClass["Sensitivity"],
    conf_matrix$byClass["Specificity"],
    conf_matrix$byClass["Pos Pred Value"],
    conf_matrix$byClass["Neg Pred Value"],
    conf_matrix$byClass["F1"],
    conf_matrix$byClass["Balanced Accuracy"]
  )
  
  data.frame(Method = method_name, Metric = names(metrics), Value = as.numeric(metrics))
}

metrics_limrots <- extract_metrics(conf_matrix_limrots, "limROTS")
metrics_rots <- extract_metrics(conf_matrix_rots, "ROTS")
metrics_limma <- extract_metrics(conf_matrix_limma, "limma")
metrics_t.test <- extract_metrics(conf_matrix_t.test, "t.test")

all_metrics <- bind_rows(metrics_limrots, metrics_rots, metrics_limma,metrics_t.test)


ggplot(all_metrics, aes(x = Metric, y = Value, fill = Method)) +
  geom_bar(stat = "identity", position = "dodge") +
  theme_bw() +
  labs(title = "Comparison of Performance Case Study0",
       y = "Value", x = "Metric") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  scale_fill_npg() + 
    theme(
    plot.title = element_text(face = "bold", color = "black"),
    axis.title = element_text(face = "bold", color = "black"),
    axis.text = element_text(face = "bold", color = "black"),
    axis.ticks = element_line(color = "black")
  )


```

-   **ROTS** and **limROTS** perform almost equally well across all metrics, with very high sensitivity, specificity, PPV, NPV, and balanced accuracy. However, ROTS edges slightly ahead in F1 score and PPV.

-   **limma** performs significantly worse than both **limROTS** and **ROTS**, especially in PPV and F1 score, making it less reliable for this particular dataset and analysis task. The lower sensitivity and specificity suggest that limma struggles with both true positive and true negative identification compared to the other two methods.

-   Previous studies have demonstrated that ROTS outperforms limma in similar scenarios across various types of omics data. This case study is intended to illustrate that the new LimROTS implementation can achieve comparable performance to ROTS when applied to this type of data, particularly in a straightforward experimental design where only two groups are being compared and no covariates are considered.

-   In the upcoming case studies, we will demonstrate how LimROTS can outperform ROTS, limma, and ANCOVA in the analysis of IDA proteomics datasets.

# UPS1 Case Study 1

## Run LimROTS

```{r results = "hide" , message = FALSE, warning = FALSE, eval=FALSE}
# Load necessary packages
library(LimROTS)
library(parallel)
# Load the dataset
data("UPS1.Case1")
print(UPS1.Case1)
# Set random seed for reproducibility
set.seed(1234, kind = "default")
# Set metadata and formula for LimROTS analysis
meta.info <- c("Conc." , "inj")
B <- 1000  # Number of bootstrap samples
K <- dim(UPS1.Case1)[1]/4 # Set the value for K based on the data size
K <- floor(K) 
num_cores <- 10  # Number of cores for parallel processing
cluster <- makeCluster(num_cores)  # Create a parallel cluster
group.name <- "Conc."
formula.str <- "~ 0 + Conc.+ inj + Conc.*inj"  # Formula for group comparison + injections
# Run LimROTS analysis with trend and robust settings enabled
limrots.result <- LimROTS(data.exp = UPS1.Case1, 
                          B = B, K = K, meta.info = meta.info, 
                          cluster = cluster, group.name = group.name, 
                          formula.str = formula.str, trend = TRUE, robust = TRUE)
saveRDS(limrots.result, "../LimROTS paper/UPS1.Case1.LimROTS.rds")
```

## Run ROTS

```{r results = "hide" , message = FALSE, warning = FALSE, eval=FALSE}
# Load necessary packages
library(LimROTS)
library(parallel)
# Load the dataset
data("UPS1.Case1")
print(UPS1.Case1)
# Set random seed for reproducibility
set.seed(1234, kind = "default")
# Set metadata and formula for LimROTS analysis
meta.info <- c("Conc." , "inj")
B <- 1000  # Number of bootstrap samples
K <- dim(UPS1.Case1)[1]/4 # Set the value for K based on the data size
K <- floor(K) 
num_cores <- 30  # Number of cores for parallel processing
cluster <- makeCluster(num_cores)  # Create a parallel cluster
group.name <- "Conc."
formula.str <- "~ 0 + Conc.+ inj + Conc.*inj"  # Formula for group comparison + injections
# Run LimROTS analysis with trend and robust settings enabled
rots.result <- LimROTS(data.exp = UPS1.Case1, 
                          B = B, K = K, meta.info = meta.info, 
                          cluster = cluster, group.name = group.name, 
                          formula.str = formula.str, trend = TRUE, robust = TRUE, n.ROTS = TRUE)
saveRDS(rots.result, "../LimROTS paper/UPS1.Case1.ROTS.rds")
```

## Run limma

```{r results = "hide" , message = FALSE, warning = FALSE, eval=FALSE}
library(limma)
library(SummarizedExperiment, quietly = T, warn.conflicts = T)
data("UPS1.Case1")
data <- assay(UPS1.Case1)
formula.str <- "~ 0 + Conc.+ inj + Conc.*inj"
meta.info <- data.frame(colData(UPS1.Case1), check.names = FALSE, row.names = row.names(colData(UPS1.Case1)))
meta.info$sample.id <- NULL
design.matrix <- model.matrix(formula(formula.str), data = meta.info)
colnames(design.matrix) <- make.names(colnames(design.matrix))
fit <- lmFit(data, design.matrix)
cont_matrix <- makeContrasts("Conc.1-Conc.2",  levels=design.matrix)
fit2 <- contrasts.fit(fit, cont_matrix)
fit.ebayes <- eBayes(fit2, trend=TRUE, robust=TRUE)
limma.result <- topTable(fit.ebayes, coef="Conc.1-Conc.2" , number = "Inf")
saveRDS(limma.result, "../LimROTS paper/UPS1.Case1.limma.rds")
```

## Run ANCOVA

```{r results = "hide" , message = FALSE, warning = FALSE, eval=FLASE}

formula.str <- "~Conc.+ inj + Conc.*inj"
data("UPS1.Case1")
data <- assay(UPS1.Case1)
meta.info <- data.frame(colData(UPS1.Case1), check.names = FALSE, row.names = row.names(colData(UPS1.Case1)))
meta.info$sample.id <- NULL
ancova.result <- data.frame()
for(i in 1:nrow(data)){
  df.temp <- data[i,]
  data.temp <- data.frame(response = as.numeric(df.temp) , Conc. = meta.info$Conc.,
                     inj = meta.info$inj)
  ancova_model <- lm(formula(paste("response", formula.str)), data = data.temp)
  coef_table <- anova(ancova_model)
  coef_table <- data.frame(coef_table)
  significant_groups <- coef_table[rownames(coef_table) == "Conc." , ]
  ancova.result <- rbind(ancova.result, data.frame(protein = row.names(data)[i], p.value =significant_groups[, 5] ))
}
ancova.result$FDR <- p.adjust(ancova.result$p.value, method = "fdr")
saveRDS(ancova.result, "../LimROTS paper/UPS1.Case1.ancova.rds")
```

## Comparison

```{r}
library(tidyverse, quietly = T, warn.conflicts = T)
library(ggsci)
limrots.result <- readRDS("../LimROTS paper/UPS1.Case1.LimROTS.rds")
rots.result <- readRDS("../LimROTS paper/UPS1.Case1.ROTS.rds")
limma.result <- readRDS("../LimROTS paper/UPS1.Case1.limma.rds")
ancova.result <- readRDS("../LimROTS paper/UPS1.Case1.ancova.rds")



alpha_thresholds <- seq(0, 0.2, by = 0.001)
significant_limROTS <- sapply(alpha_thresholds, function(alpha) sum(limrots.result$FDR < alpha))
significant_ROTS <- sapply(alpha_thresholds, function(alpha) sum(rots.result$FDR < alpha))
significant_limma <- sapply(alpha_thresholds, function(alpha) sum(limma.result$adj.P.Val < alpha))
significant_ancova <- sapply(alpha_thresholds, function(alpha) sum(ancova.result$FDR < alpha))

plot_data <- data.frame(Alpha = alpha_thresholds, significant_limROTS = significant_limROTS,
                        significant_ROTS = significant_ROTS , significant_limma = significant_limma  ,significant_ancova = significant_ancova)

plot_data.melt <-  plot_data %>%
  pivot_longer(cols = starts_with("significant"), names_to = "Method", values_to = "FDR")

# Plot using ggplot2
ggplot(plot_data.melt, aes(x = Alpha, y = FDR, color = Method)) +
  geom_line( size = 1) +
  theme_minimal() +
  labs(title = "Significant Proteins vs FDR",
       x = "FDR",
       y = "Number of Significant Proteins") +
   geom_vline(xintercept = 0.01, linetype="dotted", 
                color = "red", size=1) + 
    geom_vline(xintercept = 0.05, linetype="dotted", 
                color = "red", size=1)+
    scale_color_npg() + 
    theme(
    plot.title = element_text(face = "bold", color = "black"),
    axis.title = element_text(face = "bold", color = "black"),
    axis.text = element_text(face = "bold", color = "black"),
    axis.ticks = element_line(color = "black")
  )
```

Case Study 1 presents a more complex situation where UPS1 human proteins are removed, so no significant differences are expected among the E. coli proteins. The model has been adjusted to account for analytical replicates from different injections. The figure demonstrates that LimROTS and limma handle the data similarly in terms of the number of significant proteins. It is important to note that comparing ROTS in this case is not entirely fair, as ROTS was not designed to account for covariates. However, it is included in this case study to highlight the importance of considering covariates in differential protein analysis, were LimROTS will be more suitable to be used.

# UPS1 Case Study 2

In the final case study for IDA proteomics data, we will explore a more intricate experimental design, the data will be sourced from two software programs, Spectronaut and ScaffoldDIA. Then a synthetic, unbalanced fake batches assigned to the samples. The assignment follows the ratio: `c(rep("M", 9), rep("F", 3), rep("M", 3), rep("F", 9), rep("M", 9), rep("F", 3), rep("M", 3), rep("F", 9))`. Additionally, 100 E. coli proteins were randomly selected, and an effect size of 10 was added to each. The model was then run using these fake batches. The expected outcome is that only the UPS1 human proteins will be identified as truly significant, while none of the remaining proteins should show significant differences between the concentration groups.\
\
This scenario resembles a real-world case where the experiment involves unbalanced batch assignments or, for instance, an uneven gender ratio among the samples. LimROTS, limma and ANCOVA will be compared in that case study.

## Run LimROTS

```{r results = "hide" , message = FALSE, warning = FALSE}

# Load necessary packages
library(LimROTS)
library(parallel)

# Load the dataset
data("UPS1.Case4")
print(UPS1.Case4)

# Set random seed for reproducibility
set.seed(1234, kind = "default")

# Set metadata and formula for LimROTS analysis
meta.info <- c("Conc." , "tool" , "fake.batch")
B <- 1000  # Number of bootstrap samples
K <- dim(UPS1.Case4)[1]/4 # Set the value for K based on the data size
K <- floor(K) 
num_cores <- 30  # Number of cores for parallel processing
cluster <- makeCluster(num_cores)  # Create a parallel cluster
group.name <- "Conc."
formula.str <- "~ 0 + Conc. + tool + fake.batch"  # Formula for group comparison

# Run LimROTS analysis with trend and robust settings enabled
limrots.result <- LimROTS(data.exp = UPS1.Case4, 
                          B = B, K = K, meta.info = meta.info, 
                          cluster = cluster, group.name = group.name, 
                          formula.str = formula.str, trend = TRUE, robust = TRUE)
saveRDS(limrots.result, "../LimROTS paper/UPS1.Case2.LimROTS.rds")
```

## Run limma

```{r results = "hide" , message = FALSE, warning = FALSE}
library(limma)
library(SummarizedExperiment, quietly = T, warn.conflicts = T)
data("UPS1.Case4")
data <- assay(UPS1.Case4)
formula.str <- "~ 0 + Conc. + tool + fake.batch"
meta.info <- data.frame(colData(UPS1.Case4), check.names = FALSE, row.names = row.names(colData(UPS1.Case4)))
meta.info$sample.id <- NULL
design.matrix <- model.matrix(formula(formula.str), data = meta.info)
colnames(design.matrix) <- make.names(colnames(design.matrix))
fit <- lmFit(data, design.matrix)
cont_matrix <- makeContrasts("Conc.1-Conc.2",  levels=design.matrix)
fit2 <- contrasts.fit(fit, cont_matrix)
fit.ebayes <- eBayes(fit2, trend=TRUE, robust=TRUE)
limma.result <- topTable(fit.ebayes, coef="Conc.1-Conc.2" , number = "Inf")
saveRDS(limma.result, "../LimROTS paper/UPS1.Case2.limma.rds")
```

## Run ANCOVA

```{r results = "hide" , message = FALSE, warning = FALSE}
formula.str <- "~ Conc. + tool + fake.batch"
data("UPS1.Case4")
data <- assay(UPS1.Case4)
meta.info <- data.frame(colData(UPS1.Case4), check.names = FALSE, row.names = row.names(colData(UPS1.Case4)))
meta.info$sample.id <- NULL
ancova.result <- data.frame()
for(i in 1:nrow(data)){
  df.temp <- data[i,]
  data.temp <- data.frame(response = as.numeric(df.temp) , Conc. = meta.info$Conc.,
                     tool = meta.info$tool, fake.batch = meta.info$fake.batch )
  ancova_model <- lm(formula(paste("response", formula.str)), data = data.temp)
  coef_table <- anova(ancova_model)
  coef_table <- data.frame(coef_table)
  significant_groups <- coef_table[rownames(coef_table) == "Conc." , ]
  ancova.result <- rbind(ancova.result, data.frame(protein = row.names(data)[i], p.value =significant_groups[, 5] ))
}
ancova.result$FDR <- p.adjust(ancova.result$p.value, method = "fdr")

```

## Comparison

```{r results = "hide" , message = FALSE, warning = FALSE}
library(caret)

TP <- UPS1.Case4@elementMetadata@listData[["GeneID"]]
TP <- TP[grepl("HUMAN" , TP)]

predictions_limrots <- limrots.result$FDR < 0.01
predictions_limrots <- factor(predictions_limrots, levels = c(TRUE, FALSE))
true_labels_limrots <- ifelse(row.names(limrots.result$data) %in% TP , TRUE, FALSE)
true_labels_limrots <- factor(true_labels_limrots, levels = c(TRUE, FALSE))
conf_matrix_limrots <- confusionMatrix(predictions_limrots, true_labels_limrots)

predictions_limma <- limma.result$adj.P.Val < 0.01
predictions_limma <- factor(predictions_limma, levels = c(TRUE, FALSE))
true_labels_limma <- ifelse(row.names(limma.result) %in% TP , TRUE, FALSE)
true_labels_limma <- factor(true_labels_limma, levels = c(TRUE, FALSE))
true_labels_limma <- confusionMatrix(predictions_limma, true_labels_limma)


predictions_ancova <- ancova.result$FDR < 0.01
predictions_ancova <- factor(predictions_ancova, levels = c(TRUE, FALSE))
true_labels_ancova <- ifelse(ancova.result$protein %in% TP , TRUE, FALSE)
true_labels_ancova <- factor(true_labels_ancova, levels = c(TRUE, FALSE))
conf_matrix_ancova <- confusionMatrix(predictions_ancova, true_labels_ancova)
```

```{r}
library(dplyr, quietly = T, warn.conflicts = T)  
library(ggplot2)

extract_metrics <- function(conf_matrix, method_name) {
  metrics <- c(
    conf_matrix$byClass["Sensitivity"],
    conf_matrix$byClass["Specificity"],
    conf_matrix$byClass["Pos Pred Value"],
    conf_matrix$byClass["Neg Pred Value"],
    conf_matrix$byClass["F1"],
    conf_matrix$byClass["Balanced Accuracy"]
  )
  
  data.frame(Method = method_name, Metric = names(metrics), Value = as.numeric(metrics))
}

metrics_limrots <- extract_metrics(conf_matrix_limrots, "limROTS")
metrics_limma <- extract_metrics(conf_matrix_limma, "limma")
metrics_ancova <- extract_metrics(conf_matrix_ancova, "ANCOVA")

all_metrics <- bind_rows(metrics_limrots, metrics_limma, metrics_ancova)


ggplot(all_metrics, aes(x = Metric, y = Value, fill = Method)) +
  geom_bar(stat = "identity", position = "dodge") +
  theme_bw() +
  labs(title = "Comparison of Performance Metrics",
       y = "Value", x = "Metric") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

-   **limROTS** is clearly the best performer, with strong results across sensitivity, specificity, PPV, and F1 score, indicating a well-balanced method with accurate classification of significant and non-significant proteins.

-   **limma** and **ANCOVA** both achieve perfect sensitivity and NPV, but their extremely poor specificity and PPV suggest they misclassify many proteins as significant, leading to a high number of false positives. This results in very low F1 scores and reduced balanced accuracy, making them unreliable for this particular case study.

In biomarker and drug discovery, particularly during the discovery phase using omics approaches, accurate identification of true significant features is crucial to streamline subsequent steps, making them faster, more precise, and reliable. The selection of an appropriate statistical tool is a critical decision, given the multitude of available methods. In the context of DIA proteomics, which is an ideal experimental setup for early biomarker and drug discovery phases, many previous studies have relied on tools such as ANCOVA and limma, which were developed for broader omics applications. While these tools may be acceptable, more specialized methods should be employed for greater accuracy. LimROTS offers a robust statistical approach for identifying true significant proteins in DIA experiments, minimizing false positive discoveries. LimROTS excels by providing high balanced accuracy, strong sensitivity, and excellent specificity, making it a reliable tool for these critical phases of discovery.\
In theory, LimROTS is applicable to other types of omics, such as transcriptomics and metabolomics. However, further case studies are needed to validate its effectiveness in these areas.
