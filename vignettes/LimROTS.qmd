---
title: "LimROTS Analysis"
author: "Ali Youssef"
format: 
  html:
    toc: TRUE
editor: visual
vignette: >
  %\VignetteIndexEntry{LimROTS Analysis}
  %\VignetteEngine{quarto::html}
  %\VignetteEncoding{UTF-8}
---

# LimROTS Analysis

```{r}
# Load necessary packages
require("LimROTS")
require("parallel")
require("devtools")
require("ggplot2")
```

# UPS1 Case Study

To demonstrate LimROTS' ability to detect true negatives complex scenarios, this dataset includes 48 samples: 24 samples analyzed with Spectronaut and another 24 analyzed with ScaffoldDIA software, and 1656 proteins. Synthetic, unbalanced fake batches assigned to the samples. The assignment follows the ratio of: `c(rep("M", 9), rep("F", 3), rep("M", 3), rep("F", 9), rep("M", 9), rep("F", 3), rep("M", 3), rep("F", 9))`.

Additionally, 100 E. coli proteins were randomly selected, and an effect size of 10 was added to each. The expected outcome is that only the UPS1 human proteins will be identified as truly significant, while none of the remaining proteins should show significant differences between the concentration groups.\
\
This scenario resembles a real-world case where the experiment involves unbalanced batch assignments or, for instance, an uneven gender ratio among the samples.\

LimROTS can take a SummarizedExperiment object with all the metadata needed to run the model. In this example we importing UPS1.Case4 data available in LimROTS.

```{r}
# Load the dataset
data("UPS1.Case4")
print(UPS1.Case4)
```

### Parameter Description for `LimROTS`

`LimROTS` takes several parameters, and it should be called correctly to obtain the desired output. The parameters are divided into three different sets:

1.  **Parameters for `LimROTS` Implementation**
2.  **Parameters for the Original `ROTS` Implementation without `limma` Integration**
3.  **Common Parameters**

#### Common Parameters

-   **`data.exp`**: The input data, which can be a `SummarizedExperiment` object or a matrix where rows represent features (e.g., genes, proteins) and columns represent samples. The values should be log-transformed.
-   **`B`**: An integer specifying the number of bootstrap iterations. Default is 1000.
-   **`K`**: An optional integer representing the top list size for ranking. If not specified, it is set to one-fourth of the number of features.
-   **`a1`**: Optional numeric value used in the optimization process.
-   **`a2`**: Optional numeric value used in the optimization process.
-   **`log`**: Logical, indicating whether the data is already log-transformed. Default is `TRUE`.
-   **`progress`**: Logical, indicating whether to display a progress bar during bootstrap sampling. Default is `FALSE`.
-   **`verbose`**: Logical, indicating whether to display messages during the function's execution. Default is `TRUE`.
-   **`meta.info`**: A data frame containing sample-level metadata, where each row corresponds to a sample. It should include the grouping variable specified in `group.name`. If `data.exp` is a `SummarizedExperiment` object, `meta.info` must be a vector of the metadata needed for the model to run and can be retrieved using `colData()`.
-   **`group.name`**: A string specifying the column in `meta.info` that represents the groups or conditions for comparison.
-   **`seed.cl`**: An integer specifying the seed for randomization; if not provided, the default is 1234.
-   **`cluster`**: A parallel cluster object for distributed computation, e.g., created by `makeCluster()`. Default is 2.

#### Parameters for `LimROTS` Implementation

-   **`formula.str`**: A formula string used when covariates are present in `meta.info` for modeling. It should include "\~ 0 + ..." to exclude the intercept from the model.
-   **`robust`**: Logical, indicating whether robust fitting should be used. Default is `TRUE`.
-   **`trend`**: Logical, indicating whether to include trend fitting in the differential expression analysis. Default is `TRUE`.

#### Parameters for the Original `ROTS` Implementation

-   **`survival`**: Logical, indicating whether to enable survival analysis. If `TRUE`, then `meta.info` should contain `time` and `event` columns.
-   **`paired`**: Logical, indicating whether the data represent paired samples. Default is `FALSE`.
-   **`n.ROTS`**: Logical. If `TRUE`, all parameters related to `LimROTS` will be ignored, and the original `ROTS` analysis will run. This must be `TRUE` when `survival` or `paired` is set to `TRUE`.

### Run LimROTS with the new implementation

Additionally, `seed.cl` internally control the seed randomization during the parallel bootstrapping process. It is advisable to establish a consistent seed prior to executing `LimROTS`

```{r}
set.seed(1234, kind = "default")
```

```{r}
# Set metadata and formula for LimROTS analysis
meta.info <- c("Conc.", "tool", "fake.batch")
B <- 100 # Number of bootstrap samples
K <- 100 # Set the value for K based on the data size
K <- floor(K)
num_cores <- 4 # Number of cores for parallel processing
cluster <- makeCluster(num_cores) # Create a parallel cluster
group.name <- "Conc."
formula.str <- "~ 0 + Conc. + tool + fake.batch" # Formula for group comparison

# Run LimROTS analysis with trend and robust settings enabled
limrots.result <- LimROTS(x = UPS1.Case4,
    B = B, K = K, meta.info = meta.info,
    cluster = cluster, group.name = group.name,
    formula.str = formula.str, trend = TRUE, robust = TRUE)
```

**NOTE:** "In this instance, we configure the number of bootstrap iterations (B) and the count of top-ranked features for reproducibility optimization (K) to 100 both, in order to minimize the example's runtime. For actual analyses, it is advisable to utilize a greater number of bootstraps (e.g., 1000).

## Filter and Analyze Significant Results

```{r}
# Create a data frame from the LimROTS results
limrots.result.df <- data.frame(proteins = row.names(limrots.result$data),
    LimROTS.FC = limrots.result$corrected.logf,
    q.value = limrots.result$q_values$qvalues)

# Filter for significant proteins (FDR < 0.01)
limrots.result.df <- limrots.result.df[limrots.result.df$q.value < 0.05, ]

# Mark proteins as true positives (HUMAN UPS1 proteins)
limrots.result.df$TP <- ifelse(grepl("HUMAN", limrots.result.df$proteins), "HUMAN_TP", "ECOLI.FP")

# Count the number of true positives
table(limrots.result.df$TP)
```

## Volcano Plot with ggplot2

```{r}
# Create a data frame from the LimROTS results
limrots.result.df <- data.frame(proteins = row.names(limrots.result$data),
    LimROTS.FC = limrots.result$corrected.logf, q.value = limrots.result$q_values$qvalues)
# Mark proteins as true positives (HUMAN UPS1 proteins)
limrots.result.df$TP <- ifelse(grepl("HUMAN", limrots.result.df$proteins), "HUMAN_TP", "ECOLI_FP")

# Create a volcano plot
ggplot(limrots.result.df, aes(x = LimROTS.FC, y = -log10(q.value), color = factor(TP))) +
    geom_point(alpha = 0.8) +
    theme_bw() +
    labs(title = "Volcano Plot", x = "Log Fold Change", y = "-Log10 q.value", color = "True Positive") +
    scale_color_manual(values = c("grey", "red")) +
    geom_hline(yintercept = -log10(0.05), linetype = "dashed", color = "blue") +
    geom_hline(yintercept = -log10(0.01), linetype = "dashed", color = "black")
```

## Quality Control Plots

LimROTS generates p-values from permutation samples, along with FDR. Additionally, the `qvalue` package is used to calculate q-values and Benjamini-Hochberg adjusted p-values based on the permutation-derived p-values. These can be used as Quality Control for the LimROTS results. We recommend using permutation-derived p-values and qvalues, though they should generally be very similar to the FDR and Benjamini-Hochberg adjusted p-values.

```{r results="hide" , message=FALSE, warning=FALSE}
## Quality Control Plots

# Plot of q-values
plot(limrots.result$q_values, main = "Q-values", xlab = "Index", ylab = "Q-value")

# Histogram of q-values
hist(limrots.result$q_values, main = "Q-value Distribution", xlab = "Q-value", col = "lightgreen", border = "white")

# Summary of q-values
summary(limrots.result$q_values)
```

```{r}
sessionInfo()
```
